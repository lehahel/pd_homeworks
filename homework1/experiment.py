from subprocess import call
from time import sleep

import numpy as np
import matplotlib.pyplot as plt

from experiment_conf import *


def generate_sbatch_config(num_proc: int, sections_number: int):
    call(f'rm {SBATCH_CONFIG_PATH}', shell=True)
    with open(SBATCH_CONFIG_PATH, 'w+', encoding='utf-8') as f:
        f.write(
            '#!/bin/bash\n'
            '# -- THE FILE IS AUTOGENERATED, DO NOT EDIT -- #\n'
            f'#SBATCH --ntasks={num_proc}\n'
            '#SBATCH --cpus-per-task=2\n'
            '#SBATCH --partition=RT\n'
            '#SBATCH --job-name=example\n'
            '#SBATCH --comment="Run mpi from config"\n'
            f'#SBATCH --output={OUTPUT_FILE_PATH}\n'
            f'#SBATCH --error={ERROR_FILE_PATH}\n'
            f'mpiexec bin/MpiHomework {sections_number}\n'
        )
    call(f'chmod +x {SBATCH_CONFIG_PATH}', shell=True)

def execute_program(num_proc: int, sections_number: int):
    generate_sbatch_config(num_proc, sections_number)
    call(f"""
        #!/bin/bash
        module add mpi/openmpi4-x86_64
        sbatch {SBATCH_CONFIG_PATH} > /dev/null
        """,
        shell=True
    )
    time_info = get_time()
    iteration = 0
    while (time_info['num_proc'] != num_proc or
          time_info['sections_number'] != sections_number) \
          and iteration < GET_TIME_TIMEOUT:
        time_info = get_time()
        iteration += 1
        sleep(1)
    if iteration >= GET_TIME_TIMEOUT:
        raise Exception('Something went wrong (timeout exceeded)')
    return time_info['time']


def build_project():
    call(BUILD_SCRIPT_PATH)


def get_time():
    with open('time_log', 'r+', encoding='utf-8') as f:
        result = f.read().split()
        if len(result) != 3:
            result = [0, 0, 0]
        return {
            'num_proc': int(result[0]),
            'sections_number': int(result[1]),
            'time': float(result[2])
        }


def print_progress_bar(iteration, total, prefix = '', suffix = '',
                    decimals = 1, length = 100, fill = 'â–ˆ', printEnd = "\r"):
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + '-' * (length - filledLength)
    print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)
    if iteration == total:
        print()


def generate_plots(plots_info):
    plt.figure(figsize=(21, 10))
    for (idx, item) in enumerate(plots_info.keys()):
        plt.subplot((len(plots_info) + 2) // 3, 3, idx + 1)
        plt.plot(np.arange(MIN_NUM_PROC, MAX_NUM_PROC + 1), plots_info[item])
        plt.xlabel("processes number")
        plt.ylabel("time")
        plt.legend([f'Sections number = {item}'])
    plt.savefig("stats.png")


def update_progress_bar(iteration, total):
    prefix = 'Progress:'
    suffix = 'Executing'
    if iteration == 0:
        suffix = 'Building'
    elif iteration == total:
        suffix = 'Complete'
    print_progress_bar(
        iteration=iteration,
        total=total,
        prefix=prefix,
        suffix=suffix,
        length=50
    )

if __name__ == '__main__':
    build_project()
    update_progress_bar(
        0,
        len(SECTIONS_NUMBERS) * (MAX_NUM_PROC - MIN_NUM_PROC + 1)
    )
    plots_info = {sections_number: list() for sections_number in SECTIONS_NUMBERS}
    for (idx, sections_number) in enumerate(SECTIONS_NUMBERS):
        for num_proc in range(MIN_NUM_PROC, MAX_NUM_PROC + 1):
            time = execute_program(num_proc, sections_number)
            plots_info[sections_number].append(time)
            update_progress_bar(
                idx * (MAX_NUM_PROC - MIN_NUM_PROC + 1) + num_proc,
                len(SECTIONS_NUMBERS) * (MAX_NUM_PROC - MIN_NUM_PROC + 1)
            )
    generate_plots(plots_info)
